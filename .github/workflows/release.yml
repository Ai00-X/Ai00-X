name: release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-upload:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9
          run_install: false

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Add rustfmt & clippy
        run: |
          rustup component add rustfmt
          rustup component add clippy

      - name: Install Linux dependencies (Tauri)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev

      - name: Prepare signing key
        shell: pwsh
        run: |
          $KeyContent = "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}"
          if (-not $KeyContent) { Write-Error "TAURI_SIGNING_PRIVATE_KEY not set"; exit 1 }
          $KeyPath = "$env:RUNNER_TEMP\tauri.key"

          # Accept either raw minisign key content (two lines with 'untrusted comment:')
          # or base64-encoded full key file content. Decode when needed.
          $trimmed = $KeyContent.Trim()
          $isBase64 = $trimmed -match '^[A-Za-z0-9+/=]+$'
          $written = $false
          if ($isBase64) {
            try {
              $decodedBytes = [Convert]::FromBase64String($trimmed)
              $decodedText  = [Text.Encoding]::UTF8.GetString($decodedBytes)
              if ($decodedText -match '^untrusted comment:') {
                Set-Content -Path $KeyPath -Value $decodedText
                $written = $true
              }
            } catch { }
          }
          if (-not $written) {
            if ($KeyContent -match '^untrusted comment:') {
              Set-Content -Path $KeyPath -Value $KeyContent
            } else {
              Write-Error "TAURI_SIGNING_PRIVATE_KEY must be the minisign secret key file content (two lines starting with 'untrusted comment:') or its base64."
              exit 1
            }
          }

          echo "TAURI_SIGNING_PRIVATE_KEY=$KeyPath" >> $env:GITHUB_ENV
          if ("${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}") {
            echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD=${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" >> $env:GITHUB_ENV
          }

      - name: Frontend build
        run: pnpm build

      - name: Tauri release build
        run: pnpm tauri build

      - name: Upload Release Assets (Windows)
        if: matrix.os == 'windows-latest'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/nsis/*.sig
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/msi/*.sig
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Release Assets (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/appimage/*.AppImage
            src-tauri/target/release/bundle/appimage/*.sig
            src-tauri/target/release/bundle/deb/*.deb
            src-tauri/target/release/bundle/deb/*.sig
            src-tauri/target/release/bundle/rpm/*.rpm
            src-tauri/target/release/bundle/rpm/*.sig
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Release Assets (macOS)
        if: matrix.os == 'macos-latest'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/macos/*.dmg
            src-tauri/target/release/bundle/macos/*.sig
            src-tauri/target/release/bundle/macos/*.app.tar.gz
            src-tauri/target/release/bundle/macos/*.app.tar.gz.sig
            src-tauri/target/release/bundle/macos/*.zip
            src-tauri/target/release/bundle/macos/*.zip.sig
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  compose-latest-json:
    runs-on: ubuntu-latest
    needs: build-and-upload
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Compose latest.json
        env:
          OWNER_REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          set -e
          curl -s "https://api.github.com/repos/$OWNER_REPO/releases/tags/$TAG" > rel.json
          win_exe=$(jq -r '.assets[] | select(.name | test("\\.exe$")) | .browser_download_url' rel.json | head -n1)
          win_sig=$(jq -r '.assets[] | select(.name | test("\\.exe\\.sig$")) | .browser_download_url' rel.json | head -n1)
          linux_appimage=$(jq -r '.assets[] | select(.name | test("\\.AppImage$")) | .browser_download_url' rel.json | head -n1)
          linux_sig=$(jq -r '.assets[] | select(.name | test("\\.AppImage\\.sig$")) | .browser_download_url' rel.json | head -n1)
          mac_dmg=$(jq -r '.assets[] | select(.name | test("\\.dmg$")) | .browser_download_url' rel.json | head -n1)
          mac_dmg_sig=$(jq -r '.assets[] | select(.name | test("\\.dmg\\.sig$")) | .browser_download_url' rel.json | head -n1)
          mac_zip=$(jq -r '.assets[] | select(.name | test("\\.app\\.tar\\.gz$|\\.zip$")) | .browser_download_url' rel.json | head -n1)
          mac_zip_sig=$(jq -r '.assets[] | select(.name | test("\\.app\\.tar\\.gz\\.sig$|\\.zip\\.sig$")) | .browser_download_url' rel.json | head -n1)

          version="${TAG#v}"
          pubdate=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          mkdir -p sigs
          if [ -n "$win_sig" ]; then curl -L "$win_sig" -o sigs/win.sig; fi
          if [ -n "$linux_sig" ]; then curl -L "$linux_sig" -o sigs/linux.sig; fi
          if [ -n "$mac_dmg_sig" ]; then curl -L "$mac_dmg_sig" -o sigs/mac.sig; elif [ -n "$mac_zip_sig" ]; then curl -L "$mac_zip_sig" -o sigs/mac.sig; fi

          win_signature=""
          linux_signature=""
          mac_signature=""
          [ -f sigs/win.sig ] && win_signature=$(cat sigs/win.sig)
          [ -f sigs/linux.sig ] && linux_signature=$(cat sigs/linux.sig)
          [ -f sigs/mac.sig ] && mac_signature=$(cat sigs/mac.sig)

          platforms="{"
          if [ -n "$win_exe" ] && [ -n "$win_signature" ]; then
            platforms="$platforms \"windows-x86_64\": {\"signature\": \"$win_signature\", \"url\": \"$win_exe\" }"
          fi
          if [ -n "$linux_appimage" ] && [ -n "$linux_signature" ]; then
            [ "$platforms" != "{" ] && platforms="$platforms, "
            platforms="$platforms \"linux-x86_64\": {\"signature\": \"$linux_signature\", \"url\": \"$linux_appimage\" }"
          fi
          mac_url=""
          if [ -n "$mac_dmg" ]; then mac_url="$mac_dmg"; elif [ -n "$mac_zip" ]; then mac_url="$mac_zip"; fi
          if [ -n "$mac_url" ] && [ -n "$mac_signature" ]; then
            [ "$platforms" != "{" ] && platforms="$platforms, "
            platforms="$platforms \"darwin-aarch64\": {\"signature\": \"$mac_signature\", \"url\": \"$mac_url\" }"
          fi
          platforms="$platforms }"

          echo "{ \"version\": \"$version\", \"notes\": \"\", \"pub_date\": \"$pubdate\", \"platforms\": $platforms }" > latest.json
          ls -l latest.json

      - name: Upload latest.json to Release
        uses: softprops/action-gh-release@v1
        with:
          files: latest.json
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
